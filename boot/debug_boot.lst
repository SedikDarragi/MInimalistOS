     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000  ; Where we'll load our kernel
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E90401                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26                                      ; Save the number of sectors
    27 00000012 88F3                        mov bl, dh
    28                                      
    29                                      ; Debug: Print 'R' to show we're in disk_load
    30 00000014 B052                        mov al, 'R'
    31 00000016 B40E                        mov ah, 0x0E
    32 00000018 CD10                        int 0x10
    33                                      
    34                                      ; Use CHS read for hard disk
    35 0000001A B402                        mov ah, 0x02
    36 0000001C 88D8                        mov al, bl  ; Number of sectors to read (saved in bl)
    37 0000001E B500                        mov ch, 0x00  ; Cylinder 0
    38 00000020 B600                        mov dh, 0x00  ; Head 0
    39 00000022 B102                        mov cl, 0x02  ; Sector 2 (after MBR)
    40 00000024 B280                        mov dl, 0x80  ; First hard disk
    41 00000026 CD13                        int 0x13
    42                                      ; jc .error  ; Temporarily remove carry check
    43                                      
    44                                      ; Debug: Print 'D' to confirm disk load succeeded
    45 00000028 B044                        mov al, 'D'
    46 0000002A B40E                        mov ah, 0x0E
    47 0000002C CD10                        int 0x10
    48                                      
    49                                      ; Debug: Print 'Q' after 'D'
    50 0000002E B051                        mov al, 'Q'
    51 00000030 B40E                        mov ah, 0x0E
    52 00000032 CD10                        int 0x10
    53                                      
    54 00000034 61                          popa
    55 00000035 C3                          ret
    56                                  .error:
    57                                      ; Debug: Print 'E' for error
    58 00000036 B045                        mov al, 'E'
    59 00000038 B40E                        mov ah, 0x0E
    60 0000003A CD10                        int 0x10
    61 0000003C BE[6301]                    mov si, msg_err
    62 0000003F E8C1FF                      call print_str
    63 00000042 EBFE                        jmp $
    64                                  
    65                                  ; GDT
    66                                  gdt_start:
    67                                      ; Null descriptor (required)
    68 00000044 0000000000000000            dq 0x0
    69                                      
    70                                      ; Code segment descriptor (flat 4GB)
    71 0000004C FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    72 0000004E 0000                        dw 0x0        ; Base (bits 0-15)
    73 00000050 00                          db 0x0        ; Base (bits 16-23)
    74 00000051 9A                          db 10011010b  ; Access byte - Present, Ring 0, Code, Executable, Readable
    75 00000052 CF                          db 11001111b  ; Flags + Limit (bits 16-19) - Granularity 4KB, 32-bit
    76 00000053 00                          db 0x0        ; Base (bits 24-31)
    77                                      
    78                                      ; Data segment descriptor (flat 4GB)
    79 00000054 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    80 00000056 0000                        dw 0x0        ; Base (bits 0-15)
    81 00000058 00                          db 0x0        ; Base (bits 16-23)
    82 00000059 92                          db 10010010b  ; Access byte - Present, Ring 0, Data, Writable
    83 0000005A CF                          db 11001111b  ; Flags + Limit (bits 16-19) - Granularity 4KB, 32-bit
    84 0000005B 00                          db 0x0        ; Base (bits 24-31)
    85                                  
    86                                  gdt_end:
    87                                  
    88                                  gdt_descriptor:
    89 0000005C 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    90 0000005E [447C0000]                  dd gdt_start + 0x7C00      ; Base address of GDT (add load address)
    91                                  
    92                                  [bits 16]
    93                                  switch_to_pm:
    94                                      ; Debug: Print 'S' before switching to protected mode
    95 00000062 B053                        mov al, 'S'
    96 00000064 B40E                        mov ah, 0x0E
    97 00000066 CD10                        int 0x10
    98                                      
    99 00000068 FA                          cli
   100                                      
   101                                      ; Debug: Print 'G' without loading GDT first
   102 00000069 B047                        mov al, 'G'
   103 0000006B B40E                        mov ah, 0x0E
   104 0000006D CD10                        int 0x10
   105                                      
   106                                      ; Debug: Print 'L' immediately after G
   107 0000006F B04C                        mov al, 'L'
   108 00000071 B40E                        mov ah, 0x0E
   109 00000073 CD10                        int 0x10
   110                                      
   111                                      ; Load GDT
   112 00000075 0F0116[5C00]                lgdt [gdt_descriptor]
   113                                      
   114                                      ; Debug: Print 'I' immediately after lgdt
   115 0000007A B049                        mov al, 'I'
   116 0000007C B40E                        mov ah, 0x0E
   117 0000007E CD10                        int 0x10
   118                                      
   119                                      ; Debug: Print 'G' after loading GDT
   120 00000080 B047                        mov al, 'G'
   121 00000082 B40E                        mov ah, 0x0E
   122 00000084 CD10                        int 0x10
   123                                      
   124                                      ; Debug: Write 'M' to VGA to confirm GDT is loaded
   125                                      ; mov byte [0xB8000+6], 'M'
   126                                      ; mov byte [0xB8000+7], 0x09
   127                                      
   128                                      ; Debug: Print 'T' after memory operations
   129 00000086 B054                        mov al, 'T'
   130 00000088 BAF803                      mov dx, 0x3F8
   131 0000008B EE                          out dx, al
   132                                      
   133                                      ; Debug: Print 'L' after loading GDT
   134 0000008C B04C                        mov al, 'L'
   135 0000008E BAF803                      mov dx, 0x3F8
   136 00000091 EE                          out dx, al
   137                                      
   138                                      ; Debug: Print 'U' before cli
   139 00000092 B055                        mov al, 'U'
   140 00000094 BAF803                      mov dx, 0x3F8
   141 00000097 EE                          out dx, al
   142                                      
   143                                      ; cli  ; Temporarily remove
   144                                      
   145                                      ; Debug: Print 'C' before accessing CR0
   146 00000098 B043                        mov al, 'C'
   147 0000009A BAF803                      mov dx, 0x3F8
   148 0000009D EE                          out dx, al
   149                                      
   150                                      ; Debug: Write 'C' to VGA before CR0 write
   151                                      ; mov byte [0xB8000], 'C'
   152                                      ; mov byte [0xB8001], 0x0C
   153                                      
   154                                      ; Enable protected mode
   155                                      ; mov eax, cr0 - manual encoding for 16-bit mode
   156 0000009E 0F20C0                      db 0x0F, 0x20, 0xC0  ; mov eax, cr0
   157                                      
   158                                      ; Debug: Print 'R' after CR0 read
   159 000000A1 B052                        mov al, 'R'
   160 000000A3 BAF803                      mov dx, 0x3F8
   161 000000A6 EE                          out dx, al
   162                                      
   163 000000A7 6683C801                    or eax, 0x1
   164                                      
   165                                      ; Debug: Print 'O' after OR instruction
   166 000000AB B04F                        mov al, 'O'
   167 000000AD BAF803                      mov dx, 0x3F8
   168 000000B0 EE                          out dx, al
   169                                      
   170                                      ; mov cr0, eax - manual encoding for 16-bit mode
   171 000000B1 0F22C0                      db 0x0F, 0x22, 0xC0  ; mov cr0, eax
   172                                      
   173                                      ; Debug: Print 'W' after CR0 write
   174 000000B4 B057                        mov al, 'W'
   175 000000B6 BAF803                      mov dx, 0x3F8
   176 000000B9 EE                          out dx, al
   177                                      
   178                                      ; Debug: Print 'J' before far jump
   179 000000BA B04A                        mov al, 'J'
   180 000000BC BAF803                      mov dx, 0x3F8
   181 000000BF EE                          out dx, al
   182                                      
   183                                      ; Disable interrupts before far jump
   184 000000C0 FA                          cli
   185                                      
   186                                      ; Far jump to flush pipeline and enter protected mode
   187 000000C1 EA[C600]0800                jmp 0x08:protected_mode_entry
   188                                  
   189                                  [bits 32]
   190                                  protected_mode_entry:
   191                                      ; Write to VGA to show we reached protected mode
   192 000000C6 C60500800B0050              mov byte [0xB8000], 'P'
   193 000000CD C60501800B000F              mov byte [0xB8001], 0x0F
   194                                      
   195                                      ; Infinite loop to stop reboot loop
   196 000000D4 EBFE                        jmp $
   197                                      
   198                                      ; Set up data segment registers first
   199 000000D6 66B81000                    mov ax, 0x10  ; Data selector
   200 000000DA 8ED8                        mov ds, ax
   201 000000DC 8ED0                        mov ss, ax
   202 000000DE 8EC0                        mov es, ax
   203 000000E0 8EE0                        mov fs, ax
   204 000000E2 8EE8                        mov gs, ax
   205                                      
   206                                      ; Debug: Write 'P' to VGA in protected mode
   207 000000E4 C60500800B0050              mov byte [0xB8000], 'P'
   208 000000EB C60501800B000F              mov byte [0xB8001], 0x0F
   209                                      
   210                                      ; Debug: Print 'S' after segment setup
   211 000000F2 B053                        mov al, 'S'
   212 000000F4 66BAF803                    mov dx, 0x3F8
   213 000000F8 EE                          out dx, al
   214                                      
   215                                      ; Debug: Write '3' to VGA to confirm we're in 32-bit protected mode
   216                                      ; mov dword [0xB8004], 0x0F330F33  ; Two '3's
   217                                      
   218                                      ; Debug: Write 'K' to VGA before jumping to kernel
   219                                      ; mov dword [0xB8008], 0x0B4B0B4B  ; Two 'K's
   220                                      
   221                                      ; Debug: Write 'J' to serial before jumping
   222 000000F9 66BAF803                    mov dx, 0x3F8
   223 000000FD B04A                        mov al, 'J'
   224 000000FF EE                          out dx, al
   225                                      
   226                                      ; Jump to kernel entry point
   227 00000100 EA2F1000000800              jmp 0x08:0x102F
   228                                  
   229                                  [bits 16]
   230                                  main:
   231 00000107 FA                          cli
   232 00000108 31C0                        xor ax, ax
   233 0000010A 8ED8                        mov ds, ax
   234 0000010C 8EC0                        mov es, ax
   235 0000010E 8ED0                        mov ss, ax
   236 00000110 BC0090                      mov sp, 0x9000  ; Use a safer location for stack
   237 00000113 FB                          sti
   238                                      
   239 00000114 8816[6701]                  mov [boot_drive], dl
   240                                      
   241 00000118 BE[5701]                    mov si, msg_boot
   242 0000011B E8E5FE                      call print_str
   243                                      
   244 0000011E BB0010                      mov bx, KERNEL_OFFSET
   245 00000121 8EC3                        mov es, bx
   246 00000123 31DB                        xor bx, bx
   247                                      
   248                                      ; Fix buffer address - we want to load at 0x1000, not 0x10000
   249 00000125 B80000                      mov ax, 0x0000
   250 00000128 8EC0                        mov es, ax
   251 0000012A BB0010                      mov bx, KERNEL_OFFSET
   252                                      
   253 0000012D B620                        mov dh, 32  ; Load 32 sectors (16KB) to get the full kernel
   254 0000012F B280                        mov dl, 0x80  ; First hard disk
   255                                      
   256 00000131 BE[5E01]                    mov si, msg_load
   257 00000134 E8CCFE                      call print_str
   258 00000137 E8D7FE                      call disk_load
   259                                      
   260                                      ; Debug: Print 'Z' after disk_load returns
   261 0000013A B05A                        mov al, 'Z'
   262 0000013C B40E                        mov ah, 0x0E
   263 0000013E CD10                        int 0x10
   264                                      
   265                                      ; Debug: Print 'X' before calling switch_to_pm
   266 00000140 B058                        mov al, 'X'
   267 00000142 B40E                        mov ah, 0x0E
   268 00000144 CD10                        int 0x10
   269                                      
   270                                      ; Debug: Print 'Y' before calling switch_to_pm
   271 00000146 B059                        mov al, 'Y'
   272 00000148 B40E                        mov ah, 0x0E
   273 0000014A CD10                        int 0x10
   274                                      
   275                                      ; Debug: Print 'M' before the jump
   276 0000014C B04D                        mov al, 'M'
   277 0000014E B40E                        mov ah, 0x0E
   278 00000150 CD10                        int 0x10
   279                                      
   280 00000152 E90DFF                      jmp switch_to_pm
   281                                      
   282 00000155 EBFE                        jmp $
   283                                  
   284 00000157 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   285 0000015E 4C6F616400              msg_load db 'Load', 0
   286 00000163 45727200                msg_err db 'Err', 0
   287 00000167 00                      boot_drive db 0
   288                                  
   289                                  ; Disk packet for LBA reads
   290                                  disk_packet:
   291 00000168 10                          db 0x10      ; Packet size (16 bytes)
   292 00000169 00                          db 0         ; Reserved
   293 0000016A 0100                        dw 1         ; Number of sectors to read
   294 0000016C 0010                        dw KERNEL_OFFSET  ; Buffer offset
   295 0000016E 0000                        dw 0         ; Buffer segment (0 for real mode)
   296 00000170 0100000000000000            dq 1         ; LBA sector number (start from sector 1 after MBR)
   297                                  
   298                                  %if ($ - $$) > 510
   299                                      %error "Bootloader exceeds 510 bytes"
   300                                  %endif
   301 00000178 00<rep 86h>             times 510 - ($ - $$) db 0
   302 000001FE 55AA                    dw 0xAA55
