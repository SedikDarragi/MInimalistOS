     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E9BA00                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26 00000012 B402                        mov ah, 0x02
    27 00000014 88F0                        mov al, dh
    28 00000016 B500                        mov ch, 0x00
    29 00000018 B600                        mov dh, 0x00
    30 0000001A B102                        mov cl, 0x02
    31 0000001C CD13                        int 0x13
    32 0000001E 7208                        jc .error
    33                                      ; Debug: Print 'D' to confirm disk load succeeded
    34 00000020 B044                        mov al, 'D'
    35 00000022 B40E                        mov ah, 0x0E
    36 00000024 CD10                        int 0x10
    37 00000026 61                          popa
    38 00000027 C3                          ret
    39                                  .error:
    40 00000028 BE[0101]                    mov si, msg_err
    41 0000002B E8D5FF                      call print_str
    42 0000002E EBFE                        jmp $
    43                                  
    44                                  ; GDT
    45                                  gdt_start:
    46                                      ; Null descriptor (required)
    47 00000030 0000000000000000            dq 0x0
    48                                      
    49                                      ; Code segment descriptor
    50 00000038 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    51 0000003A 0000                        dw 0x0        ; Base (bits 0-15)
    52 0000003C 00                          db 0x0        ; Base (bits 16-23)
    53 0000003D 9A                          db 10011010b  ; Access byte
    54 0000003E CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    55 0000003F 00                          db 0x0        ; Base (bits 24-31)
    56                                      
    57                                      ; Data segment descriptor
    58 00000040 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    59 00000042 0000                        dw 0x0        ; Base (bits 0-15)
    60 00000044 00                          db 0x0        ; Base (bits 16-23)
    61 00000045 92                          db 10010010b  ; Access byte
    62 00000046 CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    63 00000047 00                          db 0x0        ; Base (bits 24-31)
    64                                  
    65                                  gdt_end:
    66                                  
    67                                  gdt_descriptor:
    68 00000048 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    69 0000004A [30000000]                  dd gdt_start                 ; Base address of GDT
    70                                  
    71                                  switch_to_pm:
    72                                      ; Debug: Print 'S' before switching to protected mode
    73 0000004E B053                        mov al, 'S'
    74 00000050 B40E                        mov ah, 0x0E
    75 00000052 CD10                        int 0x10
    76                                      
    77 00000054 FA                          cli
    78                                      
    79                                      ; Debug: Print 'G' without loading GDT first
    80 00000055 B047                        mov al, 'G'
    81 00000057 B40E                        mov ah, 0x0E
    82 00000059 CD10                        int 0x10
    83                                      
    84                                      ; Debug: Print 'L' immediately after G
    85 0000005B B04C                        mov al, 'L'
    86 0000005D B40E                        mov ah, 0x0E
    87 0000005F CD10                        int 0x10
    88                                      
    89                                      ; Load GDT - simple approach
    90 00000061 0F0116[4800]                lgdt [gdt_descriptor]
    91                                      
    92                                      ; Debug: Print 'T' after memory operations
    93 00000066 B054                        mov al, 'T'
    94 00000068 B40E                        mov ah, 0x0E
    95 0000006A CD10                        int 0x10
    96                                      
    97                                      ; Debug: Print 'L' after loading GDT
    98 0000006C B04C                        mov al, 'L'
    99 0000006E B40E                        mov ah, 0x0E
   100 00000070 CD10                        int 0x10
   101                                      
   102                                      ; Debug: Print 'C' before accessing CR0
   103 00000072 B043                        mov al, 'C'
   104 00000074 B40E                        mov ah, 0x0E
   105 00000076 CD10                        int 0x10
   106                                      
   107 00000078 0F20C0                      mov eax, cr0
   108 0000007B 6683C801                    or eax, 0x1
   109                                      
   110                                      ; Debug: Print 'R' after modifying CR0
   111 0000007F B052                        mov al, 'R'
   112 00000081 B40E                        mov ah, 0x0E
   113 00000083 CD10                        int 0x10
   114                                      
   115 00000085 0F22C0                      mov cr0, eax
   116                                      
   117                                      ; Far jump to protected mode code (must be immediate after CR0 write)
   118 00000088 EA[8D00]0800                jmp CODE_SEG:init_pm
   119                                  
   120                                  [bits 32]
   121                                  init_pm:
   122                                      ; Set up segment registers first
   123 0000008D 66B81000                    mov ax, DATA_SEG
   124 00000091 8ED8                        mov ds, ax
   125 00000093 8ED0                        mov ss, ax
   126 00000095 8EC0                        mov es, ax
   127 00000097 8EE0                        mov fs, ax
   128 00000099 8EE8                        mov gs, ax
   129 0000009B BD00000900                  mov ebp, 0x90000
   130 000000A0 89EC                        mov esp, ebp
   131                                      
   132                                      ; Debug: Write 'P' to VGA to confirm we're in protected mode
   133 000000A2 B800800B00                  mov eax, 0xB8000
   134 000000A7 C60050                      mov byte [eax], 'P'
   135 000000AA C640010F                    mov byte [eax+1], 0x0F
   136                                      
   137                                      ; Debug: Write 'J' to VGA before jumping to kernel
   138 000000AE C640024A                    mov byte [eax+2], 'J'
   139 000000B2 C640030A                    mov byte [eax+3], 0x0A
   140                                      
   141                                      ; Jump to the kernel
   142 000000B6 EA001000000800              jmp CODE_SEG:KERNEL_OFFSET
   143                                  
   144                                  [bits 16]
   145                                  main:
   146 000000BD FA                          cli
   147 000000BE 31C0                        xor ax, ax
   148 000000C0 8ED8                        mov ds, ax
   149 000000C2 8EC0                        mov es, ax
   150 000000C4 8ED0                        mov ss, ax
   151 000000C6 BC007C                      mov sp, 0x7c00
   152 000000C9 FB                          sti
   153                                      
   154 000000CA 8816[0501]                  mov [boot_drive], dl
   155                                      
   156 000000CE BE[F500]                    mov si, msg_boot
   157 000000D1 E82FFF                      call print_str
   158                                      
   159 000000D4 BB0010                      mov bx, KERNEL_OFFSET
   160 000000D7 8EC3                        mov es, bx
   161 000000D9 31DB                        xor bx, bx
   162 000000DB B60F                        mov dh, 15
   163 000000DD 8A16[0501]                  mov dl, [boot_drive]
   164                                      
   165 000000E1 BE[FC00]                    mov si, msg_load
   166 000000E4 E81CFF                      call print_str
   167 000000E7 E827FF                      call disk_load
   168                                      
   169                                      ; Debug: Print 'X' before calling switch_to_pm
   170 000000EA B058                        mov al, 'X'
   171 000000EC B40E                        mov ah, 0x0E
   172 000000EE CD10                        int 0x10
   173                                      
   174 000000F0 E85BFF                      call switch_to_pm
   175                                      
   176 000000F3 EBFE                        jmp $
   177                                  
   178 000000F5 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   179 000000FC 4C6F616400              msg_load db 'Load', 0
   180 00000101 45727200                msg_err db 'Err', 0
   181 00000105 00                      boot_drive db 0
   182                                  
   183                                  %if ($ - $$) > 510
   184                                      %error "Bootloader exceeds 510 bytes"
   185                                  %endif
   186 00000106 00<rep F8h>             times 510 - ($ - $$) db 0
   187 000001FE 55AA                    dw 0xAA55
