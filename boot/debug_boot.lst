     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000  ; Where we'll load our kernel
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E9F400                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26                                      ; Save the number of sectors
    27 00000012 88F3                        mov bl, dh
    28                                      
    29                                      ; Debug: Print 'R' to show we're in disk_load
    30 00000014 B052                        mov al, 'R'
    31 00000016 B40E                        mov ah, 0x0E
    32 00000018 CD10                        int 0x10
    33                                      
    34                                      ; Use CHS read for hard disk
    35 0000001A B402                        mov ah, 0x02
    36 0000001C 88D8                        mov al, bl  ; Number of sectors to read (saved in bl)
    37 0000001E B500                        mov ch, 0x00  ; Cylinder 0
    38 00000020 B600                        mov dh, 0x00  ; Head 0
    39 00000022 B102                        mov cl, 0x02  ; Sector 2 (after MBR)
    40 00000024 B280                        mov dl, 0x80  ; First hard disk
    41 00000026 CD13                        int 0x13
    42                                      ; jc .error  ; Temporarily remove carry check
    43                                      
    44                                      ; Debug: Print 'D' to confirm disk load succeeded
    45 00000028 B044                        mov al, 'D'
    46 0000002A B40E                        mov ah, 0x0E
    47 0000002C CD10                        int 0x10
    48                                      
    49                                      ; Debug: Print 'Q' after 'D'
    50 0000002E B051                        mov al, 'Q'
    51 00000030 B40E                        mov ah, 0x0E
    52 00000032 CD10                        int 0x10
    53                                      
    54 00000034 61                          popa
    55 00000035 C3                          ret
    56                                  .error:
    57                                      ; Debug: Print 'E' for error
    58 00000036 B045                        mov al, 'E'
    59 00000038 B40E                        mov ah, 0x0E
    60 0000003A CD10                        int 0x10
    61 0000003C BE[5301]                    mov si, msg_err
    62 0000003F E8C1FF                      call print_str
    63 00000042 EBFE                        jmp $
    64                                  
    65                                  ; GDT
    66                                  gdt_start:
    67                                      ; Null descriptor (required)
    68 00000044 0000000000000000            dq 0x0
    69                                      
    70                                      ; Code segment descriptor
    71 0000004C FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    72 0000004E 0000                        dw 0x0        ; Base (bits 0-15)
    73 00000050 00                          db 0x0        ; Base (bits 16-23)
    74 00000051 9A                          db 10011010b  ; Access byte
    75 00000052 CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    76 00000053 00                          db 0x0        ; Base (bits 24-31)
    77                                      
    78                                      ; Data segment descriptor
    79 00000054 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    80 00000056 0000                        dw 0x0        ; Base (bits 0-15)
    81 00000058 00                          db 0x0        ; Base (bits 16-23)
    82 00000059 92                          db 10010010b  ; Access byte
    83 0000005A CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    84 0000005B 00                          db 0x0        ; Base (bits 24-31)
    85                                  
    86                                  gdt_end:
    87                                  
    88                                  gdt_descriptor:
    89 0000005C 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    90 0000005E [447C0000]                  dd gdt_start + 0x7C00      ; Base address of GDT (add load address)
    91                                  
    92                                  [bits 16]
    93                                  switch_to_pm:
    94                                      ; Debug: Print 'S' before switching to protected mode
    95 00000062 B053                        mov al, 'S'
    96 00000064 B40E                        mov ah, 0x0E
    97 00000066 CD10                        int 0x10
    98                                      
    99 00000068 FA                          cli
   100                                      
   101                                      ; Debug: Print 'G' without loading GDT first
   102 00000069 B047                        mov al, 'G'
   103 0000006B B40E                        mov ah, 0x0E
   104 0000006D CD10                        int 0x10
   105                                      
   106                                      ; Debug: Print 'L' immediately after G
   107 0000006F B04C                        mov al, 'L'
   108 00000071 B40E                        mov ah, 0x0E
   109 00000073 CD10                        int 0x10
   110                                      
   111                                      ; Load GDT
   112 00000075 0F0116[5C00]                lgdt [gdt_descriptor]
   113                                      
   114                                      ; Debug: Print 'I' immediately after lgdt
   115 0000007A B049                        mov al, 'I'
   116 0000007C B40E                        mov ah, 0x0E
   117 0000007E CD10                        int 0x10
   118                                      
   119                                      ; Debug: Print 'G' after loading GDT
   120 00000080 B047                        mov al, 'G'
   121 00000082 B40E                        mov ah, 0x0E
   122 00000084 CD10                        int 0x10
   123                                      
   124                                      ; Debug: Write 'M' to VGA to confirm GDT is loaded
   125                                      ; mov byte [0xB8000+6], 'M'
   126                                      ; mov byte [0xB8000+7], 0x09
   127                                      
   128                                      ; Debug: Print 'T' after memory operations
   129 00000086 B054                        mov al, 'T'
   130 00000088 BAF803                      mov dx, 0x3F8
   131 0000008B EE                          out dx, al
   132                                      
   133                                      ; Debug: Print 'L' after loading GDT
   134 0000008C B04C                        mov al, 'L'
   135 0000008E BAF803                      mov dx, 0x3F8
   136 00000091 EE                          out dx, al
   137                                      
   138                                      ; Debug: Print 'U' before cli
   139 00000092 B055                        mov al, 'U'
   140 00000094 BAF803                      mov dx, 0x3F8
   141 00000097 EE                          out dx, al
   142                                      
   143                                      ; cli  ; Temporarily remove
   144                                      
   145                                      ; Debug: Print 'C' before accessing CR0
   146 00000098 B043                        mov al, 'C'
   147 0000009A BAF803                      mov dx, 0x3F8
   148 0000009D EE                          out dx, al
   149                                      
   150                                      ; Debug: Write 'C' to VGA before CR0 write
   151                                      ; mov byte [0xB8000], 'C'
   152                                      ; mov byte [0xB8001], 0x0C
   153                                      
   154                                      ; Enable protected mode
   155                                      ; mov eax, cr0 - manual encoding for 16-bit mode
   156 0000009E 0F20C0                      db 0x0F, 0x20, 0xC0  ; mov eax, cr0
   157                                      
   158                                      ; Debug: Print 'R' after CR0 read
   159 000000A1 B052                        mov al, 'R'
   160 000000A3 BAF803                      mov dx, 0x3F8
   161 000000A6 EE                          out dx, al
   162                                      
   163 000000A7 6683C801                    or eax, 0x1
   164                                      
   165                                      ; Debug: Print 'O' after OR instruction
   166 000000AB B04F                        mov al, 'O'
   167 000000AD BAF803                      mov dx, 0x3F8
   168 000000B0 EE                          out dx, al
   169                                      
   170                                      ; mov cr0, eax - manual encoding for 16-bit mode
   171 000000B1 0F22C0                      db 0x0F, 0x22, 0xC0  ; mov cr0, eax
   172                                      
   173                                      ; Debug: Print 'W' after CR0 write
   174 000000B4 B057                        mov al, 'W'
   175 000000B6 BAF803                      mov dx, 0x3F8
   176 000000B9 EE                          out dx, al
   177                                      
   178                                      ; Debug: Print 'J' before far jump
   179 000000BA B04A                        mov al, 'J'
   180 000000BC BAF803                      mov dx, 0x3F8
   181 000000BF EE                          out dx, al
   182                                      
   183                                      ; Disable interrupts before far jump
   184 000000C0 FA                          cli
   185                                      
   186                                      ; Far jump to flush pipeline and enter protected mode
   187                                      ; jmp far 0x08:0x7CC5 - manual encoding
   188 000000C1 EA                          db 0xEA  ; jmp far opcode
   189 000000C2 C57C                        dw 0x7CC5  ; offset
   190 000000C4 0800                        dw 0x0008  ; segment
   191                                  
   192                                  [bits 32]
   193                                  protected_mode_entry:
   194                                      ; Set up data segment registers first
   195 000000C6 66B81000                    mov ax, 0x10  ; Data selector
   196 000000CA 8ED8                        mov ds, ax
   197 000000CC 8ED0                        mov ss, ax
   198 000000CE 8EC0                        mov es, ax
   199 000000D0 8EE0                        mov fs, ax
   200 000000D2 8EE8                        mov gs, ax
   201                                      
   202                                      ; Debug: Write 'P' to VGA in protected mode
   203 000000D4 C60500800B0050              mov byte [0xB8000], 'P'
   204 000000DB C60501800B000F              mov byte [0xB8001], 0x0F
   205                                      
   206                                      ; Debug: Print 'S' after segment setup
   207 000000E2 B053                        mov al, 'S'
   208 000000E4 66BAF803                    mov dx, 0x3F8
   209 000000E8 EE                          out dx, al
   210                                      
   211                                      ; Debug: Write '3' to VGA to confirm we're in 32-bit protected mode
   212                                      ; mov dword [0xB8004], 0x0F330F33  ; Two '3's
   213                                      
   214                                      ; Debug: Write 'K' to VGA before jumping to kernel
   215                                      ; mov dword [0xB8008], 0x0B4B0B4B  ; Two 'K's
   216                                      
   217                                      ; Debug: Write 'J' to serial before jumping
   218 000000E9 66BAF803                    mov dx, 0x3F8
   219 000000ED B04A                        mov al, 'J'
   220 000000EF EE                          out dx, al
   221                                      
   222                                      ; Jump to kernel entry point
   223 000000F0 EA2F1000000800              jmp 0x08:0x102F
   224                                  
   225                                  [bits 16]
   226                                  main:
   227 000000F7 FA                          cli
   228 000000F8 31C0                        xor ax, ax
   229 000000FA 8ED8                        mov ds, ax
   230 000000FC 8EC0                        mov es, ax
   231 000000FE 8ED0                        mov ss, ax
   232 00000100 BC0090                      mov sp, 0x9000  ; Use a safer location for stack
   233 00000103 FB                          sti
   234                                      
   235 00000104 8816[5701]                  mov [boot_drive], dl
   236                                      
   237 00000108 BE[4701]                    mov si, msg_boot
   238 0000010B E8F5FE                      call print_str
   239                                      
   240 0000010E BB0010                      mov bx, KERNEL_OFFSET
   241 00000111 8EC3                        mov es, bx
   242 00000113 31DB                        xor bx, bx
   243                                      
   244                                      ; Fix buffer address - we want to load at 0x1000, not 0x10000
   245 00000115 B80000                      mov ax, 0x0000
   246 00000118 8EC0                        mov es, ax
   247 0000011A BB0010                      mov bx, KERNEL_OFFSET
   248                                      
   249 0000011D B620                        mov dh, 32  ; Load 32 sectors (16KB) to get the full kernel
   250 0000011F B280                        mov dl, 0x80  ; First hard disk
   251                                      
   252 00000121 BE[4E01]                    mov si, msg_load
   253 00000124 E8DCFE                      call print_str
   254 00000127 E8E7FE                      call disk_load
   255                                      
   256                                      ; Debug: Print 'Z' after disk_load returns
   257 0000012A B05A                        mov al, 'Z'
   258 0000012C B40E                        mov ah, 0x0E
   259 0000012E CD10                        int 0x10
   260                                      
   261                                      ; Debug: Print 'X' before calling switch_to_pm
   262 00000130 B058                        mov al, 'X'
   263 00000132 B40E                        mov ah, 0x0E
   264 00000134 CD10                        int 0x10
   265                                      
   266                                      ; Debug: Print 'Y' before calling switch_to_pm
   267 00000136 B059                        mov al, 'Y'
   268 00000138 B40E                        mov ah, 0x0E
   269 0000013A CD10                        int 0x10
   270                                      
   271                                      ; Debug: Print 'M' before the jump
   272 0000013C B04D                        mov al, 'M'
   273 0000013E B40E                        mov ah, 0x0E
   274 00000140 CD10                        int 0x10
   275                                      
   276 00000142 E91DFF                      jmp switch_to_pm
   277                                      
   278 00000145 EBFE                        jmp $
   279                                  
   280 00000147 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   281 0000014E 4C6F616400              msg_load db 'Load', 0
   282 00000153 45727200                msg_err db 'Err', 0
   283 00000157 00                      boot_drive db 0
   284                                  
   285                                  ; Disk packet for LBA reads
   286                                  disk_packet:
   287 00000158 10                          db 0x10      ; Packet size (16 bytes)
   288 00000159 00                          db 0         ; Reserved
   289 0000015A 0100                        dw 1         ; Number of sectors to read
   290 0000015C 0010                        dw KERNEL_OFFSET  ; Buffer offset
   291 0000015E 0000                        dw 0         ; Buffer segment (0 for real mode)
   292 00000160 0100000000000000            dq 1         ; LBA sector number (start from sector 1 after MBR)
   293                                  
   294                                  %if ($ - $$) > 510
   295                                      %error "Bootloader exceeds 510 bytes"
   296                                  %endif
   297 00000168 00<rep 96h>             times 510 - ($ - $$) db 0
   298 000001FE 55AA                    dw 0xAA55
