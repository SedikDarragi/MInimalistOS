     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000  ; Where we'll load our kernel
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E9C000                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26                                      ; Save the number of sectors
    27 00000012 88F3                        mov bl, dh
    28                                      
    29                                      ; Debug: Print 'R' to show we're in disk_load
    30 00000014 B052                        mov al, 'R'
    31 00000016 B40E                        mov ah, 0x0E
    32 00000018 CD10                        int 0x10
    33                                      
    34                                      ; Use CHS read for hard disk
    35 0000001A B402                        mov ah, 0x02
    36 0000001C 88D8                        mov al, bl  ; Number of sectors to read (saved in bl)
    37 0000001E B500                        mov ch, 0x00  ; Cylinder 0
    38 00000020 B600                        mov dh, 0x00  ; Head 0
    39 00000022 B102                        mov cl, 0x02  ; Sector 2 (after MBR)
    40 00000024 B280                        mov dl, 0x80  ; First hard disk
    41 00000026 CD13                        int 0x13
    42                                      ; jc .error  ; Temporarily remove carry check
    43                                      
    44                                      ; Debug: Print 'D' to confirm disk load succeeded
    45 00000028 B044                        mov al, 'D'
    46 0000002A B40E                        mov ah, 0x0E
    47 0000002C CD10                        int 0x10
    48                                      
    49                                      ; Debug: Print 'Q' after 'D'
    50 0000002E B051                        mov al, 'Q'
    51 00000030 B40E                        mov ah, 0x0E
    52 00000032 CD10                        int 0x10
    53                                      
    54 00000034 61                          popa
    55 00000035 C3                          ret
    56                                  .error:
    57                                      ; Debug: Print 'E' for error
    58 00000036 B045                        mov al, 'E'
    59 00000038 B40E                        mov ah, 0x0E
    60 0000003A CD10                        int 0x10
    61 0000003C BE[1F01]                    mov si, msg_err
    62 0000003F E8C1FF                      call print_str
    63 00000042 EBFE                        jmp $
    64                                  
    65                                  ; GDT
    66                                  gdt_start:
    67                                      ; Null descriptor (required)
    68 00000044 0000000000000000            dq 0x0
    69                                      
    70                                      ; Code segment descriptor
    71 0000004C FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    72 0000004E 0000                        dw 0x0        ; Base (bits 0-15)
    73 00000050 00                          db 0x0        ; Base (bits 16-23)
    74 00000051 9A                          db 10011010b  ; Access byte
    75 00000052 CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    76 00000053 00                          db 0x0        ; Base (bits 24-31)
    77                                      
    78                                      ; Data segment descriptor
    79 00000054 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    80 00000056 0000                        dw 0x0        ; Base (bits 0-15)
    81 00000058 00                          db 0x0        ; Base (bits 16-23)
    82 00000059 92                          db 10010010b  ; Access byte
    83 0000005A CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    84 0000005B 00                          db 0x0        ; Base (bits 24-31)
    85                                  
    86                                  gdt_end:
    87                                  
    88                                  gdt_descriptor:
    89 0000005C 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    90 0000005E [447C0000]                  dd gdt_start + 0x7C00      ; Base address of GDT (add load address)
    91                                  
    92                                  switch_to_pm:
    93                                      ; Debug: Print 'S' before switching to protected mode
    94 00000062 B053                        mov al, 'S'
    95 00000064 B40E                        mov ah, 0x0E
    96 00000066 CD10                        int 0x10
    97                                      
    98 00000068 FA                          cli
    99                                      
   100                                      ; Debug: Print 'G' without loading GDT first
   101 00000069 B047                        mov al, 'G'
   102 0000006B B40E                        mov ah, 0x0E
   103 0000006D CD10                        int 0x10
   104                                      
   105                                      ; Debug: Print 'L' immediately after G
   106 0000006F B04C                        mov al, 'L'
   107 00000071 B40E                        mov ah, 0x0E
   108 00000073 CD10                        int 0x10
   109                                      
   110                                      ; Load GDT
   111 00000075 0F0116[5C00]                lgdt [gdt_descriptor]
   112                                      
   113                                      ; Debug: Print 'I' immediately after lgdt
   114 0000007A B049                        mov al, 'I'
   115 0000007C B40E                        mov ah, 0x0E
   116 0000007E CD10                        int 0x10
   117                                      
   118                                      ; Debug: Print 'G' after loading GDT
   119 00000080 B047                        mov al, 'G'
   120 00000082 B40E                        mov ah, 0x0E
   121 00000084 CD10                        int 0x10
   122                                      
   123                                      ; Debug: Write 'M' to VGA to confirm GDT is loaded
   124                                      ; mov byte [0xB8000+6], 'M'
   125                                      ; mov byte [0xB8000+7], 0x09
   126                                      
   127                                      ; Debug: Print 'T' after memory operations
   128 00000086 B054                        mov al, 'T'
   129 00000088 B40E                        mov ah, 0x0E
   130 0000008A CD10                        int 0x10
   131                                      
   132                                      ; Debug: Print 'L' after loading GDT
   133 0000008C B04C                        mov al, 'L'
   134 0000008E B40E                        mov ah, 0x0E
   135 00000090 CD10                        int 0x10
   136                                      
   137                                      ; Debug: Print 'C' before accessing CR0
   138 00000092 B043                        mov al, 'C'
   139 00000094 B40E                        mov ah, 0x0E
   140 00000096 CD10                        int 0x10
   141                                      
   142                                      ; Debug: Write 'C' to VGA before CR0 write
   143                                      ; mov byte [0xB8000], 'C'
   144                                      ; mov byte [0xB8001], 0x0C
   145                                      
   146                                      ; Enable protected mode
   147 00000098 0F20C0                      mov eax, cr0
   148 0000009B 6683C801                    or eax, 0x1
   149 0000009F 0F22C0                      mov cr0, eax
   150                                      
   151                                      ; Debug: Write 'P' to VGA after CR0 write
   152                                      ; mov byte [0xB8002], 'P'
   153                                      ; mov byte [0xB8003], 0x0E
   154                                      
   155                                      ; Debug: Write 'J' to VGA before the far jump
   156                                      ; mov byte [0xB8006], 'J'
   157                                      ; mov byte [0xB8007], 0x0A
   158                                      
   159                                      ; Far jump to flush pipeline and enter protected mode
   160 000000A2 EAC37C0800                  jmp 0x08:0x7CC3
   161                                  
   162                                  [bits 32]
   163                                  protected_mode_entry:
   164                                      ; Set up data segment registers
   165 000000A7 66B81000                    mov ax, 0x10  ; Data selector
   166 000000AB 8ED8                        mov ds, ax
   167 000000AD 8ED0                        mov ss, ax
   168 000000AF 8EC0                        mov es, ax
   169 000000B1 8EE0                        mov fs, ax
   170 000000B3 8EE8                        mov gs, ax
   171                                      
   172                                      ; Debug: Write '3' to VGA to confirm we're in 32-bit protected mode
   173                                      ; mov dword [0xB8004], 0x0F330F33  ; Two '3's
   174                                      
   175                                      ; Debug: Write 'K' to VGA before jumping to kernel
   176                                      ; mov dword [0xB8008], 0x0B4B0B4B  ; Two 'K's
   177                                      
   178                                      ; Debug: Write 'J' to serial before jumping
   179 000000B5 66BAF803                    mov dx, 0x3F8
   180 000000B9 B04A                        mov al, 'J'
   181 000000BB EE                          out dx, al
   182                                      
   183                                      ; Jump to kernel entry point
   184 000000BC EA2F1000000800              jmp 0x08:0x102F
   185                                  
   186                                  [bits 16]
   187                                  main:
   188 000000C3 FA                          cli
   189 000000C4 31C0                        xor ax, ax
   190 000000C6 8ED8                        mov ds, ax
   191 000000C8 8EC0                        mov es, ax
   192 000000CA 8ED0                        mov ss, ax
   193 000000CC BC007C                      mov sp, 0x7c00
   194 000000CF FB                          sti
   195                                      
   196 000000D0 8816[2301]                  mov [boot_drive], dl
   197                                      
   198 000000D4 BE[1301]                    mov si, msg_boot
   199 000000D7 E829FF                      call print_str
   200                                      
   201 000000DA BB0010                      mov bx, KERNEL_OFFSET
   202 000000DD 8EC3                        mov es, bx
   203 000000DF 31DB                        xor bx, bx
   204                                      
   205                                      ; Fix buffer address - we want to load at 0x1000, not 0x10000
   206 000000E1 B80000                      mov ax, 0x0000
   207 000000E4 8EC0                        mov es, ax
   208 000000E6 BB0010                      mov bx, KERNEL_OFFSET
   209                                      
   210 000000E9 B620                        mov dh, 32  ; Load 32 sectors (16KB) to get the full kernel
   211 000000EB B280                        mov dl, 0x80  ; First hard disk
   212                                      
   213 000000ED BE[1A01]                    mov si, msg_load
   214 000000F0 E810FF                      call print_str
   215 000000F3 E81BFF                      call disk_load
   216                                      
   217                                      ; Debug: Print 'Z' after disk_load returns
   218 000000F6 B05A                        mov al, 'Z'
   219 000000F8 B40E                        mov ah, 0x0E
   220 000000FA CD10                        int 0x10
   221                                      
   222                                      ; Debug: Print 'X' before calling switch_to_pm
   223 000000FC B058                        mov al, 'X'
   224 000000FE B40E                        mov ah, 0x0E
   225 00000100 CD10                        int 0x10
   226                                      
   227                                      ; Debug: Print 'Y' before calling switch_to_pm
   228 00000102 B059                        mov al, 'Y'
   229 00000104 B40E                        mov ah, 0x0E
   230 00000106 CD10                        int 0x10
   231                                      
   232                                      ; Debug: Print 'M' before the jump
   233 00000108 B04D                        mov al, 'M'
   234 0000010A B40E                        mov ah, 0x0E
   235 0000010C CD10                        int 0x10
   236                                      
   237 0000010E E951FF                      jmp switch_to_pm
   238                                      
   239 00000111 EBFE                        jmp $
   240                                  
   241 00000113 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   242 0000011A 4C6F616400              msg_load db 'Load', 0
   243 0000011F 45727200                msg_err db 'Err', 0
   244 00000123 00                      boot_drive db 0
   245                                  
   246                                  ; Disk packet for LBA reads
   247                                  disk_packet:
   248 00000124 10                          db 0x10      ; Packet size (16 bytes)
   249 00000125 00                          db 0         ; Reserved
   250 00000126 0100                        dw 1         ; Number of sectors to read
   251 00000128 0010                        dw KERNEL_OFFSET  ; Buffer offset
   252 0000012A 0000                        dw 0         ; Buffer segment (0 for real mode)
   253 0000012C 0100000000000000            dq 1         ; LBA sector number (start from sector 1 after MBR)
   254                                  
   255                                  %if ($ - $$) > 510
   256                                      %error "Bootloader exceeds 510 bytes"
   257                                  %endif
   258 00000134 00<rep CAh>             times 510 - ($ - $$) db 0
   259 000001FE 55AA                    dw 0xAA55
