     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000  ; Where we'll load our kernel
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E9EC00                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26                                      ; Save the number of sectors
    27 00000012 88F3                        mov bl, dh
    28                                      
    29                                      ; Debug: Print 'R' to show we're in disk_load
    30 00000014 B052                        mov al, 'R'
    31 00000016 B40E                        mov ah, 0x0E
    32 00000018 CD10                        int 0x10
    33                                      
    34                                      ; Use CHS read for hard disk
    35 0000001A B402                        mov ah, 0x02
    36 0000001C 88D8                        mov al, bl  ; Number of sectors to read (saved in bl)
    37 0000001E B500                        mov ch, 0x00  ; Cylinder 0
    38 00000020 B600                        mov dh, 0x00  ; Head 0
    39 00000022 B102                        mov cl, 0x02  ; Sector 2 (after MBR)
    40 00000024 B280                        mov dl, 0x80  ; First hard disk
    41 00000026 CD13                        int 0x13
    42                                      ; jc .error  ; Temporarily remove carry check
    43                                      
    44                                      ; Debug: Print 'D' to confirm disk load succeeded
    45 00000028 B044                        mov al, 'D'
    46 0000002A B40E                        mov ah, 0x0E
    47 0000002C CD10                        int 0x10
    48                                      
    49                                      ; Debug: Print 'Q' after 'D'
    50 0000002E B051                        mov al, 'Q'
    51 00000030 B40E                        mov ah, 0x0E
    52 00000032 CD10                        int 0x10
    53                                      
    54 00000034 61                          popa
    55 00000035 C3                          ret
    56                                  .error:
    57                                      ; Debug: Print 'E' for error
    58 00000036 B045                        mov al, 'E'
    59 00000038 B40E                        mov ah, 0x0E
    60 0000003A CD10                        int 0x10
    61 0000003C BE[4B01]                    mov si, msg_err
    62 0000003F E8C1FF                      call print_str
    63 00000042 EBFE                        jmp $
    64                                  
    65                                  ; GDT
    66                                  gdt_start:
    67                                      ; Null descriptor (required)
    68 00000044 0000000000000000            dq 0x0
    69                                      
    70                                      ; Code segment descriptor
    71 0000004C FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    72 0000004E 0000                        dw 0x0        ; Base (bits 0-15)
    73 00000050 00                          db 0x0        ; Base (bits 16-23)
    74 00000051 9A                          db 10011010b  ; Access byte
    75 00000052 CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    76 00000053 00                          db 0x0        ; Base (bits 24-31)
    77                                      
    78                                      ; Data segment descriptor
    79 00000054 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    80 00000056 0000                        dw 0x0        ; Base (bits 0-15)
    81 00000058 00                          db 0x0        ; Base (bits 16-23)
    82 00000059 92                          db 10010010b  ; Access byte
    83 0000005A CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    84 0000005B 00                          db 0x0        ; Base (bits 24-31)
    85                                  
    86                                  gdt_end:
    87                                  
    88                                  gdt_descriptor:
    89 0000005C 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    90 0000005E [447C0000]                  dd gdt_start + 0x7C00      ; Base address of GDT (add load address)
    91                                  
    92                                  [bits 16]
    93                                  switch_to_pm:
    94                                      ; Debug: Print 'S' before switching to protected mode
    95 00000062 B053                        mov al, 'S'
    96 00000064 B40E                        mov ah, 0x0E
    97 00000066 CD10                        int 0x10
    98                                      
    99 00000068 FA                          cli
   100                                      
   101                                      ; Debug: Print 'G' without loading GDT first
   102 00000069 B047                        mov al, 'G'
   103 0000006B B40E                        mov ah, 0x0E
   104 0000006D CD10                        int 0x10
   105                                      
   106                                      ; Debug: Print 'L' immediately after G
   107 0000006F B04C                        mov al, 'L'
   108 00000071 B40E                        mov ah, 0x0E
   109 00000073 CD10                        int 0x10
   110                                      
   111                                      ; Load GDT
   112 00000075 0F0116[5C00]                lgdt [gdt_descriptor]
   113                                      
   114                                      ; Debug: Print 'I' immediately after lgdt
   115 0000007A B049                        mov al, 'I'
   116 0000007C B40E                        mov ah, 0x0E
   117 0000007E CD10                        int 0x10
   118                                      
   119                                      ; Debug: Print 'G' after loading GDT
   120 00000080 B047                        mov al, 'G'
   121 00000082 B40E                        mov ah, 0x0E
   122 00000084 CD10                        int 0x10
   123                                      
   124                                      ; Debug: Write 'M' to VGA to confirm GDT is loaded
   125                                      ; mov byte [0xB8000+6], 'M'
   126                                      ; mov byte [0xB8000+7], 0x09
   127                                      
   128                                      ; Debug: Print 'T' after memory operations
   129 00000086 B054                        mov al, 'T'
   130 00000088 BAF803                      mov dx, 0x3F8
   131 0000008B EE                          out dx, al
   132                                      
   133                                      ; Debug: Print 'L' after loading GDT
   134 0000008C B04C                        mov al, 'L'
   135 0000008E BAF803                      mov dx, 0x3F8
   136 00000091 EE                          out dx, al
   137                                      
   138                                      ; Debug: Print 'U' before cli
   139 00000092 B055                        mov al, 'U'
   140 00000094 BAF803                      mov dx, 0x3F8
   141 00000097 EE                          out dx, al
   142                                      
   143                                      ; cli  ; Temporarily remove
   144                                      
   145                                      ; Debug: Print 'C' before accessing CR0
   146 00000098 B043                        mov al, 'C'
   147 0000009A BAF803                      mov dx, 0x3F8
   148 0000009D EE                          out dx, al
   149                                      
   150                                      ; Debug: Write 'C' to VGA before CR0 write
   151                                      ; mov byte [0xB8000], 'C'
   152                                      ; mov byte [0xB8001], 0x0C
   153                                      
   154                                      ; Enable protected mode
   155                                      ; mov eax, cr0 - manual encoding for 16-bit mode
   156 0000009E 0F20C0                      db 0x0F, 0x20, 0xC0  ; mov eax, cr0
   157                                      
   158                                      ; Debug: Print 'R' after CR0 read
   159 000000A1 B052                        mov al, 'R'
   160 000000A3 BAF803                      mov dx, 0x3F8
   161 000000A6 EE                          out dx, al
   162                                      
   163 000000A7 6683C801                    or eax, 0x1
   164                                      
   165                                      ; Debug: Print 'O' after OR instruction
   166 000000AB B04F                        mov al, 'O'
   167 000000AD BAF803                      mov dx, 0x3F8
   168 000000B0 EE                          out dx, al
   169                                      
   170                                      ; mov cr0, eax - manual encoding for 16-bit mode
   171 000000B1 0F22C0                      db 0x0F, 0x22, 0xC0  ; mov cr0, eax
   172                                      
   173                                      ; Debug: Print 'W' after CR0 write
   174 000000B4 B057                        mov al, 'W'
   175 000000B6 BAF803                      mov dx, 0x3F8
   176 000000B9 EE                          out dx, al
   177                                      
   178                                      ; Debug: Print 'J' before far jump
   179 000000BA B04A                        mov al, 'J'
   180 000000BC BAF803                      mov dx, 0x3F8
   181 000000BF EE                          out dx, al
   182                                      
   183                                      ; Far jump to flush pipeline and enter protected mode
   184                                      ; jmp far 0x08:0x7CC5 - manual encoding
   185 000000C0 EA                          db 0xEA  ; jmp far opcode
   186 000000C1 C57C                        dw 0x7CC5  ; offset
   187 000000C3 0800                        dw 0x0008  ; segment
   188                                  
   189                                  [bits 32]
   190                                  protected_mode_entry:
   191                                      ; Debug: Print 'P' in protected mode
   192 000000C5 B050                        mov al, 'P'
   193 000000C7 66BAF803                    mov dx, 0x3F8
   194 000000CB EE                          out dx, al
   195                                      
   196                                      ; Set up data segment registers
   197 000000CC 66B81000                    mov ax, 0x10  ; Data selector
   198 000000D0 8ED8                        mov ds, ax
   199 000000D2 8ED0                        mov ss, ax
   200 000000D4 8EC0                        mov es, ax
   201 000000D6 8EE0                        mov fs, ax
   202 000000D8 8EE8                        mov gs, ax
   203                                      
   204                                      ; Debug: Print 'S' after segment setup
   205 000000DA B053                        mov al, 'S'
   206 000000DC 66BAF803                    mov dx, 0x3F8
   207 000000E0 EE                          out dx, al
   208                                      
   209                                      ; Debug: Write '3' to VGA to confirm we're in 32-bit protected mode
   210                                      ; mov dword [0xB8004], 0x0F330F33  ; Two '3's
   211                                      
   212                                      ; Debug: Write 'K' to VGA before jumping to kernel
   213                                      ; mov dword [0xB8008], 0x0B4B0B4B  ; Two 'K's
   214                                      
   215                                      ; Debug: Write 'J' to serial before jumping
   216 000000E1 66BAF803                    mov dx, 0x3F8
   217 000000E5 B04A                        mov al, 'J'
   218 000000E7 EE                          out dx, al
   219                                      
   220                                      ; Jump to kernel entry point
   221 000000E8 EA2F1000000800              jmp 0x08:0x102F
   222                                  
   223                                  [bits 16]
   224                                  main:
   225 000000EF FA                          cli
   226 000000F0 31C0                        xor ax, ax
   227 000000F2 8ED8                        mov ds, ax
   228 000000F4 8EC0                        mov es, ax
   229 000000F6 8ED0                        mov ss, ax
   230 000000F8 BC0090                      mov sp, 0x9000  ; Use a safer location for stack
   231 000000FB FB                          sti
   232                                      
   233 000000FC 8816[4F01]                  mov [boot_drive], dl
   234                                      
   235 00000100 BE[3F01]                    mov si, msg_boot
   236 00000103 E8FDFE                      call print_str
   237                                      
   238 00000106 BB0010                      mov bx, KERNEL_OFFSET
   239 00000109 8EC3                        mov es, bx
   240 0000010B 31DB                        xor bx, bx
   241                                      
   242                                      ; Fix buffer address - we want to load at 0x1000, not 0x10000
   243 0000010D B80000                      mov ax, 0x0000
   244 00000110 8EC0                        mov es, ax
   245 00000112 BB0010                      mov bx, KERNEL_OFFSET
   246                                      
   247 00000115 B620                        mov dh, 32  ; Load 32 sectors (16KB) to get the full kernel
   248 00000117 B280                        mov dl, 0x80  ; First hard disk
   249                                      
   250 00000119 BE[4601]                    mov si, msg_load
   251 0000011C E8E4FE                      call print_str
   252 0000011F E8EFFE                      call disk_load
   253                                      
   254                                      ; Debug: Print 'Z' after disk_load returns
   255 00000122 B05A                        mov al, 'Z'
   256 00000124 B40E                        mov ah, 0x0E
   257 00000126 CD10                        int 0x10
   258                                      
   259                                      ; Debug: Print 'X' before calling switch_to_pm
   260 00000128 B058                        mov al, 'X'
   261 0000012A B40E                        mov ah, 0x0E
   262 0000012C CD10                        int 0x10
   263                                      
   264                                      ; Debug: Print 'Y' before calling switch_to_pm
   265 0000012E B059                        mov al, 'Y'
   266 00000130 B40E                        mov ah, 0x0E
   267 00000132 CD10                        int 0x10
   268                                      
   269                                      ; Debug: Print 'M' before the jump
   270 00000134 B04D                        mov al, 'M'
   271 00000136 B40E                        mov ah, 0x0E
   272 00000138 CD10                        int 0x10
   273                                      
   274 0000013A E925FF                      jmp switch_to_pm
   275                                      
   276 0000013D EBFE                        jmp $
   277                                  
   278 0000013F 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   279 00000146 4C6F616400              msg_load db 'Load', 0
   280 0000014B 45727200                msg_err db 'Err', 0
   281 0000014F 00                      boot_drive db 0
   282                                  
   283                                  ; Disk packet for LBA reads
   284                                  disk_packet:
   285 00000150 10                          db 0x10      ; Packet size (16 bytes)
   286 00000151 00                          db 0         ; Reserved
   287 00000152 0100                        dw 1         ; Number of sectors to read
   288 00000154 0010                        dw KERNEL_OFFSET  ; Buffer offset
   289 00000156 0000                        dw 0         ; Buffer segment (0 for real mode)
   290 00000158 0100000000000000            dq 1         ; LBA sector number (start from sector 1 after MBR)
   291                                  
   292                                  %if ($ - $$) > 510
   293                                      %error "Bootloader exceeds 510 bytes"
   294                                  %endif
   295 00000160 00<rep 9Eh>             times 510 - ($ - $$) db 0
   296 000001FE 55AA                    dw 0xAA55
