     1                                  [org 0x7c00]
     2                                  [bits 16]
     3                                  
     4                                  KERNEL_OFFSET equ 0x1000  ; Where we'll load our kernel
     5                                  CODE_SEG equ 8
     6                                  DATA_SEG equ 16
     7                                  
     8                                  _start:
     9 00000000 E9F400                      jmp main
    10                                  
    11                                  print_str:
    12 00000003 60                          pusha
    13 00000004 B40E                        mov ah, 0x0E
    14                                  .loop:
    15 00000006 AC                          lodsb
    16 00000007 84C0                        test al, al
    17 00000009 7404                        jz .done
    18 0000000B CD10                        int 0x10
    19 0000000D EBF7                        jmp .loop
    20                                  .done:
    21 0000000F 61                          popa
    22 00000010 C3                          ret
    23                                  
    24                                  disk_load:
    25 00000011 60                          pusha
    26                                      ; Save the number of sectors
    27 00000012 88F3                        mov bl, dh
    28                                      
    29                                      ; Debug: Print 'R' to show we're in disk_load
    30 00000014 B052                        mov al, 'R'
    31 00000016 B40E                        mov ah, 0x0E
    32 00000018 CD10                        int 0x10
    33                                      
    34                                      ; Use CHS read for hard disk
    35 0000001A B402                        mov ah, 0x02
    36 0000001C 88D8                        mov al, bl  ; Number of sectors to read (saved in bl)
    37 0000001E B500                        mov ch, 0x00  ; Cylinder 0
    38 00000020 B600                        mov dh, 0x00  ; Head 0
    39 00000022 B102                        mov cl, 0x02  ; Sector 2 (after MBR)
    40 00000024 B280                        mov dl, 0x80  ; First hard disk
    41 00000026 CD13                        int 0x13
    42                                      ; jc .error  ; Temporarily remove carry check
    43                                      
    44                                      ; Debug: Print 'D' to confirm disk load succeeded
    45 00000028 B044                        mov al, 'D'
    46 0000002A B40E                        mov ah, 0x0E
    47 0000002C CD10                        int 0x10
    48                                      
    49                                      ; Debug: Print 'Q' after 'D'
    50 0000002E B051                        mov al, 'Q'
    51 00000030 B40E                        mov ah, 0x0E
    52 00000032 CD10                        int 0x10
    53                                      
    54 00000034 61                          popa
    55 00000035 C3                          ret
    56                                  .error:
    57                                      ; Debug: Print 'E' for error
    58 00000036 B045                        mov al, 'E'
    59 00000038 B40E                        mov ah, 0x0E
    60 0000003A CD10                        int 0x10
    61 0000003C BE[5301]                    mov si, msg_err
    62 0000003F E8C1FF                      call print_str
    63 00000042 EBFE                        jmp $
    64                                  
    65                                  ; GDT
    66                                  gdt_start:
    67                                      ; Null descriptor (required)
    68 00000044 0000000000000000            dq 0x0
    69                                      
    70                                      ; Code segment descriptor
    71 0000004C FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    72 0000004E 0000                        dw 0x0        ; Base (bits 0-15)
    73 00000050 00                          db 0x0        ; Base (bits 16-23)
    74 00000051 9A                          db 10011010b  ; Access byte
    75 00000052 CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    76 00000053 00                          db 0x0        ; Base (bits 24-31)
    77                                      
    78                                      ; Data segment descriptor
    79 00000054 FFFF                        dw 0xFFFF     ; Limit (bits 0-15)
    80 00000056 0000                        dw 0x0        ; Base (bits 0-15)
    81 00000058 00                          db 0x0        ; Base (bits 16-23)
    82 00000059 92                          db 10010010b  ; Access byte
    83 0000005A CF                          db 11001111b  ; Flags + Limit (bits 16-19)
    84 0000005B 00                          db 0x0        ; Base (bits 24-31)
    85                                  
    86                                  gdt_end:
    87                                  
    88                                  gdt_descriptor:
    89 0000005C 1700                        dw gdt_end - gdt_start - 1  ; Size of GDT
    90 0000005E [447C0000]                  dd gdt_start + 0x7C00      ; Base address of GDT (add load address)
    91                                  
    92                                  [bits 16]
    93                                  switch_to_pm:
    94                                      ; Debug: Print 'S' before switching to protected mode
    95 00000062 B053                        mov al, 'S'
    96 00000064 B40E                        mov ah, 0x0E
    97 00000066 CD10                        int 0x10
    98                                      
    99 00000068 FA                          cli
   100                                      
   101                                      ; Debug: Print 'G' without loading GDT first
   102 00000069 B047                        mov al, 'G'
   103 0000006B B40E                        mov ah, 0x0E
   104 0000006D CD10                        int 0x10
   105                                      
   106                                      ; Debug: Print 'L' immediately after G
   107 0000006F B04C                        mov al, 'L'
   108 00000071 B40E                        mov ah, 0x0E
   109 00000073 CD10                        int 0x10
   110                                      
   111                                      ; Load GDT
   112 00000075 0F0116[5C00]                lgdt [gdt_descriptor]
   113                                      
   114                                      ; Debug: Print 'I' immediately after lgdt
   115 0000007A B049                        mov al, 'I'
   116 0000007C B40E                        mov ah, 0x0E
   117 0000007E CD10                        int 0x10
   118                                      
   119                                      ; Debug: Print 'G' after loading GDT
   120 00000080 B047                        mov al, 'G'
   121 00000082 B40E                        mov ah, 0x0E
   122 00000084 CD10                        int 0x10
   123                                      
   124                                      ; Debug: Write 'M' to VGA to confirm GDT is loaded
   125                                      ; mov byte [0xB8000+6], 'M'
   126                                      ; mov byte [0xB8000+7], 0x09
   127                                      
   128                                      ; Debug: Print 'T' after memory operations
   129 00000086 B054                        mov al, 'T'
   130 00000088 BAF803                      mov dx, 0x3F8
   131 0000008B EE                          out dx, al
   132                                      
   133                                      ; Debug: Print 'L' after loading GDT
   134 0000008C B04C                        mov al, 'L'
   135 0000008E BAF803                      mov dx, 0x3F8
   136 00000091 EE                          out dx, al
   137                                      
   138                                      ; Debug: Print 'U' before cli
   139 00000092 B055                        mov al, 'U'
   140 00000094 BAF803                      mov dx, 0x3F8
   141 00000097 EE                          out dx, al
   142                                      
   143                                      ; cli  ; Temporarily remove
   144                                      
   145                                      ; Debug: Print 'C' before accessing CR0
   146 00000098 B043                        mov al, 'C'
   147 0000009A BAF803                      mov dx, 0x3F8
   148 0000009D EE                          out dx, al
   149                                      
   150                                      ; Debug: Write 'C' to VGA before CR0 write
   151                                      ; mov byte [0xB8000], 'C'
   152                                      ; mov byte [0xB8001], 0x0C
   153                                      
   154                                      ; Enable protected mode
   155                                      ; mov eax, cr0 - manual encoding for 16-bit mode
   156 0000009E 0F20C0                      db 0x0F, 0x20, 0xC0  ; mov eax, cr0
   157                                      
   158                                      ; Debug: Print 'R' after CR0 read
   159 000000A1 B052                        mov al, 'R'
   160 000000A3 BAF803                      mov dx, 0x3F8
   161 000000A6 EE                          out dx, al
   162                                      
   163 000000A7 6683C801                    or eax, 0x1
   164                                      
   165                                      ; Debug: Print 'O' after OR instruction
   166 000000AB B04F                        mov al, 'O'
   167 000000AD BAF803                      mov dx, 0x3F8
   168 000000B0 EE                          out dx, al
   169                                      
   170                                      ; mov cr0, eax - manual encoding for 16-bit mode
   171 000000B1 0F22C0                      db 0x0F, 0x22, 0xC0  ; mov cr0, eax
   172                                      
   173                                      ; Debug: Print 'W' after CR0 write
   174 000000B4 B057                        mov al, 'W'
   175 000000B6 BAF803                      mov dx, 0x3F8
   176 000000B9 EE                          out dx, al
   177                                      
   178                                      ; Debug: Print 'J' before far jump
   179 000000BA B04A                        mov al, 'J'
   180 000000BC BAF803                      mov dx, 0x3F8
   181 000000BF EE                          out dx, al
   182                                      
   183                                      ; Disable interrupts before far jump
   184 000000C0 FA                          cli
   185                                      
   186                                      ; Far jump to flush pipeline and enter protected mode
   187 000000C1 EA[C600]0800                jmp 0x08:protected_mode_entry
   188                                  
   189                                  [bits 32]
   190                                  protected_mode_entry:
   191                                      ; Set up data segment registers first
   192 000000C6 66B81000                    mov ax, 0x10  ; Data selector
   193 000000CA 8ED8                        mov ds, ax
   194 000000CC 8ED0                        mov ss, ax
   195 000000CE 8EC0                        mov es, ax
   196 000000D0 8EE0                        mov fs, ax
   197 000000D2 8EE8                        mov gs, ax
   198                                      
   199                                      ; Debug: Write 'P' to VGA in protected mode
   200 000000D4 C60500800B0050              mov byte [0xB8000], 'P'
   201 000000DB C60501800B000F              mov byte [0xB8001], 0x0F
   202                                      
   203                                      ; Debug: Print 'S' after segment setup
   204 000000E2 B053                        mov al, 'S'
   205 000000E4 66BAF803                    mov dx, 0x3F8
   206 000000E8 EE                          out dx, al
   207                                      
   208                                      ; Debug: Write '3' to VGA to confirm we're in 32-bit protected mode
   209                                      ; mov dword [0xB8004], 0x0F330F33  ; Two '3's
   210                                      
   211                                      ; Debug: Write 'K' to VGA before jumping to kernel
   212                                      ; mov dword [0xB8008], 0x0B4B0B4B  ; Two 'K's
   213                                      
   214                                      ; Debug: Write 'J' to serial before jumping
   215 000000E9 66BAF803                    mov dx, 0x3F8
   216 000000ED B04A                        mov al, 'J'
   217 000000EF EE                          out dx, al
   218                                      
   219                                      ; Jump to kernel entry point
   220 000000F0 EA2F1000000800              jmp 0x08:0x102F
   221                                  
   222                                  [bits 16]
   223                                  main:
   224 000000F7 FA                          cli
   225 000000F8 31C0                        xor ax, ax
   226 000000FA 8ED8                        mov ds, ax
   227 000000FC 8EC0                        mov es, ax
   228 000000FE 8ED0                        mov ss, ax
   229 00000100 BC0090                      mov sp, 0x9000  ; Use a safer location for stack
   230 00000103 FB                          sti
   231                                      
   232 00000104 8816[5701]                  mov [boot_drive], dl
   233                                      
   234 00000108 BE[4701]                    mov si, msg_boot
   235 0000010B E8F5FE                      call print_str
   236                                      
   237 0000010E BB0010                      mov bx, KERNEL_OFFSET
   238 00000111 8EC3                        mov es, bx
   239 00000113 31DB                        xor bx, bx
   240                                      
   241                                      ; Fix buffer address - we want to load at 0x1000, not 0x10000
   242 00000115 B80000                      mov ax, 0x0000
   243 00000118 8EC0                        mov es, ax
   244 0000011A BB0010                      mov bx, KERNEL_OFFSET
   245                                      
   246 0000011D B620                        mov dh, 32  ; Load 32 sectors (16KB) to get the full kernel
   247 0000011F B280                        mov dl, 0x80  ; First hard disk
   248                                      
   249 00000121 BE[4E01]                    mov si, msg_load
   250 00000124 E8DCFE                      call print_str
   251 00000127 E8E7FE                      call disk_load
   252                                      
   253                                      ; Debug: Print 'Z' after disk_load returns
   254 0000012A B05A                        mov al, 'Z'
   255 0000012C B40E                        mov ah, 0x0E
   256 0000012E CD10                        int 0x10
   257                                      
   258                                      ; Debug: Print 'X' before calling switch_to_pm
   259 00000130 B058                        mov al, 'X'
   260 00000132 B40E                        mov ah, 0x0E
   261 00000134 CD10                        int 0x10
   262                                      
   263                                      ; Debug: Print 'Y' before calling switch_to_pm
   264 00000136 B059                        mov al, 'Y'
   265 00000138 B40E                        mov ah, 0x0E
   266 0000013A CD10                        int 0x10
   267                                      
   268                                      ; Debug: Print 'M' before the jump
   269 0000013C B04D                        mov al, 'M'
   270 0000013E B40E                        mov ah, 0x0E
   271 00000140 CD10                        int 0x10
   272                                      
   273 00000142 E91DFF                      jmp switch_to_pm
   274                                      
   275 00000145 EBFE                        jmp $
   276                                  
   277 00000147 426F6F740D0A00          msg_boot db 'Boot', 0x0D, 0x0A, 0
   278 0000014E 4C6F616400              msg_load db 'Load', 0
   279 00000153 45727200                msg_err db 'Err', 0
   280 00000157 00                      boot_drive db 0
   281                                  
   282                                  ; Disk packet for LBA reads
   283                                  disk_packet:
   284 00000158 10                          db 0x10      ; Packet size (16 bytes)
   285 00000159 00                          db 0         ; Reserved
   286 0000015A 0100                        dw 1         ; Number of sectors to read
   287 0000015C 0010                        dw KERNEL_OFFSET  ; Buffer offset
   288 0000015E 0000                        dw 0         ; Buffer segment (0 for real mode)
   289 00000160 0100000000000000            dq 1         ; LBA sector number (start from sector 1 after MBR)
   290                                  
   291                                  %if ($ - $$) > 510
   292                                      %error "Bootloader exceeds 510 bytes"
   293                                  %endif
   294 00000168 00<rep 96h>             times 510 - ($ - $$) db 0
   295 000001FE 55AA                    dw 0xAA55
